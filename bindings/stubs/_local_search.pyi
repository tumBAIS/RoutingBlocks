class ArcSet:
    def __init__(self, number_of_vertices: int) -> None: ...

    def forbid_arc(self, origin_vertex_id: VertexID, target_vertex_id: VertexID) -> None: ...

    def include_arc(self, origin_vertex_id: VertexID, target_vertex_id: VertexID) -> None: ...

    def includes_arc(self, origin_vertex_id: VertexID, target_vertex_id: VertexID) -> bool: ...


class GeneratorArc:
    @overload
    def __init__(self, solution: Solution, origin_route_index: int, origin_node_position: int, target_route_index: int,
                 target_node_position: int) -> None: ...

    @overload
    def __init__(self, solution: Solution, origin_location: NodeLocation, target_location: NodeLocation) -> None: ...

    @property
    def origin_node(self) -> Node: ...

    @property
    def origin_route(self) -> Route: ...

    @property
    def target_node(self) -> Node: ...

    @property
    def target_route(self) -> Route: ...


class Move:
    def __init__(self) -> None: ...

    def apply(self, instance: Instance, solution: Solution) -> None: ...

    def get_cost_delta(self, evaluation: Evaluation, instance: Instance, solution: Solution) -> float: ...


class LocalSearchOperator:
    def __init__(self) -> None: ...

    def finalize_search(self) -> None: ...

    def find_next_improving_move(self, evaluation: Evaluation, solution: Solution,
                                 last_evaluated_move: Move) -> Move: ...

    def prepare_search(self, solution: Solution) -> None: ...


class LocalSearch:
    def __init__(self, instance: Instance, evaluation: Evaluation, exact_evaluation: Optional[Evaluation]) -> None: ...

    def optimize(self, solution: Solution, operator: List[LocalSearchOperator]) -> None: ...

    def set_use_best_improvement(self, best_improvement: bool) -> None: ...


class QuadraticNeighborhoodIterator:
    def __init__(self) -> None: ...


def iter_neighborhood(solution: Solution) -> Iterator: ...

from typing import Any, List, Tuple


class Evaluation:
    def __init__(self) -> None: ...

    def compute_cost(self, label: AnyForwardLabel) -> float: ...

    def evaluate(self, instance: Instance,
                 segments: List[List[Tuple[Vertex, AnyForwardLabel, AnyBackwardLabel]]]) -> float: ...

    def create_backward_label(self, vertex: Vertex) -> AnyBackwardLabel: ...

    def create_forward_label(self, vertex: Vertex) -> AnyForwardLabel: ...

    def get_cost_components(self, label: AnyForwardLabel) -> List[float]: ...

    def is_feasible(self, label: AnyForwardLabel) -> bool: ...

    def propagate_backward(self, pred_label: AnyForwardLabel, pred_vertex: Vertex, vertex: Vertex,
                           arc: Arc) -> AnyBackwardLabel: ...

    def propagate_forward(self, succ_label: AnyBackwardLabel, succ_vertex: Vertex, vertex: Vertex,
                          arc: Arc) -> AnyForwardLabel: ...


class PyEvaluation(Evaluation):
    ...


class PyConcatenationBasedEvaluation(Evaluation):
    def __init__(self) -> None: ...

    def concatenate(self, fwd: AnyForwardLabel, bwd: AnyBackwardLabel, vertex: Vertex) -> float: ...


@overload
def evaluate_insertion(evaluation: Evaluation, instance: Instance, route: Route, after_position: VertexID,
                       vertex_id: VertexID) -> float: ...


@overload
def evaluate_insertion(evaluation: Evaluation, instance: Instance, route: Route, after_position: VertexID,
                       vertex: Vertex) -> float: ...


@overload
def evaluate_insertion(evaluation: Evaluation, instance: Instance, route: Route, after_position: VertexID,
                       node: Node) -> float: ...


def evaluate_splice(evaluation: Evaluation, instance: Instance, route: Route, forward_segment_end_pos: int,
                    backward_segment_begin_pos: int) -> float: ...
